- 書き込み側blockしちゃったよモードの作成
- accept()をqueueが空になるまで繰り返すべきかどうか
- fairness
- connect()の後ってほっとけばいいのか、exceptfdsを見てからactiveにするのか？

-----------------------------
onoeさんのメール

Subject: Re: faith
From: Atsushi Onoe <onoe@sm.sony.co.jp>
To: shin@nd.net.fujitsu.co.jp
Cc: core@kame.net
Date: Tue, 15 Dec 1998 14:13:53 +0900 (JST)
X-Mailer: Cue version 0.3 (981215-1046/onoe)

> faithdのrelayの件ですが、tcp_relay()はそのままにしておいて、relay()に
> 以下を追加してみました。

これだと結局 blocking write になるので、write 側が一杯になっていると
process が止まってしまって、反対方向も service されなくなると思います。

正しくは、
	select は1箇所
	各 stream 毎に、
		基本は read 側だけで select
		write は non-blocking にしておく
		write が EWOULDBLOCK したら、
			該当データは queueing
			write 側で select
			read 側は待たない (FD_CLR)
			write 側を書き切ったら read select に戻る
という手順になると思います。

複数の connection を扱う場合は fairness にも気を使う必要がありますが、
単一の双方向コネクションであれば、そんなに気にしなくても良いでしょう。
	この上で ppp とかやる人がいることまで考えるなら、select の
	後の FD_ISSET をやる順番を振ることによって fairness を保つ
	というのも有効かも知れません。

> あと、block, non-blockingという辺りが分らないのですが、non-blockingだ
> とすると、writeの返り値をcheckしてまだ残りがあればそこで再度selectとかし
> た方よいでのでしょうか?

1bit だけで select するのなら blocking write しても同じです。

blocking write
	本当にエラーにならない限り、1バイトは書かれる
	queue full のときには block する
		(select で writable になるまで待つのと一緒)
	全部書かれる保証はない

non-blocking write
	queue full のときに -1 (EWOULDBLOCK)
	全部書かれる保証はない

	non-blocking select (tv.sec = tv.usec = 0) して書けるときだけ
	blocking write しても動作的には同等
		もちろん、non-blocking write の方が system call が少ない
		ぶんだけ軽い

この手のプログラムは、1 stream が止まっているときに他を止めないのが基本
なので、
	1. select を使って、絶対 block しないように書く (telnet)
	2. thread を使って書く
	3. fork() してしまって 2 process で書く (rlogin)
などの方法になります。美しいのは 2. なんだろうけどね。

尾上
